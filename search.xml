<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>githubPic</title>
    <url>/2020/03/26/githubPic/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>cppstatic</title>
    <url>/2020/03/26/cppstatic/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>gameInterview</title>
    <url>/2020/03/20/gameInterview/</url>
    <content><![CDATA[<h2 id="游戏开发方向学习与面试资源总结"><a href="#游戏开发方向学习与面试资源总结" class="headerlink" title="游戏开发方向学习与面试资源总结"></a>游戏开发方向学习与面试资源总结</h2><h2 id="1-网站"><a href="#1-网站" class="headerlink" title="1.网站"></a>1.网站</h2><p><a href="https://interview.huihut.com/#/?id=const" target="_blank" rel="noopener">https://interview.huihut.com/#/?id=const</a></p>
]]></content>
  </entry>
  <entry>
    <title>C++ Const关键字总结</title>
    <url>/2020/03/20/cppconst/</url>
    <content><![CDATA[<h2 id="C-Const-关键字"><a href="#C-Const-关键字" class="headerlink" title="C++ Const 关键字"></a>C++ Const 关键字</h2><p>Const 是修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。</p>
<p>P.S.更多解释请直接阅读cppreference</p>
<h2 id="1-内置类型变量"><a href="#1-内置类型变量" class="headerlink" title="1.内置类型变量"></a>1.内置类型变量</h2><p>Const修饰全局变量时，编译器不允许修改定义好的变量。如果修改，则报错。</p>
<p>Const修饰局部变量时，编译器仍然不允许直接赋值修改，但是可以通过地址修改值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>  a = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span>  *p = (<span class="keyword">int</span>*)&amp;a; <span class="comment">//如果没有显示转换会报错：错误C2440: 无法从“ const int *”转换为“int * ”</span></span><br><span class="line">*p = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a;</span><br></pre></td></tr></table></figure>

<p>调试可知a变量的值被改变为8，但是输出的结果仍然是 7。</p>
<p>在使用变量名输出时，编译器会出现一种类似宏定义的功能一样的行为，将变量名替换为初始值。可见，const局部变量并不能做到真正的不变，而是编译器对其进行了一些优化行为，这导致了const局部变量与真实值产生了不一致。</p>
<p>如果想获取修改后的const局部变量真实值，可以使用volatile关键字。volatile关键字使得程序每次直接去内存中读取变量值而不是读寄存器值，这个作用在解决一些不是程序而是由于别的原因修改了变量值时非常有用。</p>
<h2 id="2-const-的指针与引用"><a href="#2-const-的指针与引用" class="headerlink" title="2.const 的指针与引用"></a>2.const 的指针与引用</h2><h3 id="const修饰指针"><a href="#const修饰指针" class="headerlink" title="const修饰指针"></a>const修饰指针</h3><p>指向常量的指针（pointer to const）/ (low-level const)</p>
<p>自身是常量的指针（常量指针，const pointer）/ (top-level const)</p>
<p>指针自身是一个对象，它的值为一个整数，表明指向对象的内存地址。因此指针长度所指向对象类型无关，在32位系统下为4字节，64位系统下为8字节。进而，指针本身是否是常量以及所指向的对象是否是常量就是两个独立的问题。</p>
<h3 id="const修饰引用"><a href="#const修饰引用" class="headerlink" title="const修饰引用"></a>const修饰引用</h3><p>指向常量的引用（reference to const）</p>
<p>没有 const reference，因为引用本身就是 const pointer</p>
<h2 id="3-const修饰函数参数传递"><a href="#3-const修饰函数参数传递" class="headerlink" title="3. const修饰函数参数传递"></a>3. const修饰函数参数传递</h2><p>const修饰参数是为了防止函数体内可能会修改参数<strong>原始对象</strong>。因此，有三种情况可讨论：</p>
<ol>
<li><p>函数参数为值传递：值传递（pass-by-value）是传递一份参数的拷贝给函数，因此不论函数体代码如何运行，也只会修改拷贝而无法修改原始对象，这种情况不需要将参数声明为const。</p>
</li>
<li><p>函数参数为指针：指针传递（pass-by-pointer）只会进行浅拷贝，拷贝一份指针给函数，而不会拷贝一份原始对象。因此，给指针参数加上顶层const可以防止指针指向被篡改，加上底层const可以防止指向对象被篡改。</p>
</li>
<li><p>函数参数为引用：引用传递（pass-by-reference）有一个很重要的作用，由于引用就是对象的一个别名，因此不需要拷贝对象，减小了开销。这同时也导致可以通过修改引用直接修改原始对象（毕竟引用和原始对象其实是同一个东西），因此，大多数时候，推荐函数参数设置为pass-by-reference-to-const。给引用加上底层const，既可以减小拷贝开销，又可以防止修改底层所引用的对象。</p>
</li>
</ol>
<h2 id="4-对于-const-修饰函数的返回值"><a href="#4-对于-const-修饰函数的返回值" class="headerlink" title="4.对于 const 修饰函数的返回值"></a>4.对于 const 修饰函数的返回值</h2><p>const修饰内置类型或者自定义类型的返回值，返回的值不能作为左值使用，既不能被赋值，也不能被修改。</p>
<h2 id="5-const修饰成员函数"><a href="#5-const修饰成员函数" class="headerlink" title="5. const修饰成员函数"></a>5. const修饰成员函数</h2><p>const修饰成员函数，是防止成员函数修改类对象的内容。良好的类接口设计应该确保，如果一个成员函数功能上不需要修改对象的内容，该成员函数应该加上const修饰。</p>
<p>如果const成员函数想修改成员变量值，可以用mutable修饰目标成员变量。</p>
<p>注意：如果一个类对象为const 对象，语义上说明该对象的值不可改变，因此该const对象只能调用const成员函数，因为非const成员函数不能保证不修改对象值，编译器会禁止这种会造成隐患的行为。</p>
<p>注意：const 关键字不能与 static 关键字同时使用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，即不能实例化，const 成员函数必须具体到某一实例。</p>
<hr>
<p>总结与举例</p>
<ol>
<li><p>修饰变量，说明该变量不可以被改变；</p>
</li>
<li><p>修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）；</p>
</li>
<li><p>修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；</p>
</li>
<li><p>修饰成员函数，说明该成员函数内不能修改成员变量。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    A() : a(<span class="number">0</span>) &#123; &#125;;</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 对象</span></span><br><span class="line">    A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line">    <span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line">    <span class="keyword">const</span> A *p = &amp;a;            <span class="comment">// 指针变量，指向常对象</span></span><br><span class="line">    <span class="keyword">const</span> A &amp;q = a;             <span class="comment">// 指向常对象的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针</span></span><br><span class="line">    <span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变）</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变）</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 自身是常量的指针，指向字符数组常量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">function5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">function6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = function6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">function7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = function7();</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><a href="https://www.runoob.com/w3cnote/cpp-const-keyword.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/cpp-const-keyword.html</a></p>
<p><a href="https://interview.huihut.com/#/?id=const-%e7%9a%84%e6%8c%87%e9%92%88%e4%b8%8e%e5%bc%95%e7%94%a8" target="_blank" rel="noopener">https://interview.huihut.com/#/?id=const-%e7%9a%84%e6%8c%87%e9%92%88%e4%b8%8e%e5%bc%95%e7%94%a8</a></p>
<p><a href="https://blog.csdn.net/u011333734/article/details/81294043" target="_blank" rel="noopener">https://blog.csdn.net/u011333734/article/details/81294043</a></p>
]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>编程技术</tag>
        <tag>CPP</tag>
        <tag>CPP面试</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编程方法：Pimpl</title>
    <url>/2020/03/09/cppimpl/</url>
    <content><![CDATA[<p>最近参与制作游戏需要跨平台，发现windows和ps4的API有很大的不同。为了代码复用，学习了Pimpl方法，可以较好的解决这个问题。</p>
<p>P.S.更多解释请直接阅读cppreference</p>
<h2 id="什么是Pimpl"><a href="#什么是Pimpl" class="headerlink" title="什么是Pimpl"></a>什么是Pimpl</h2><p>Pimpl（pointer to implementation）是“指向实现的指针”。</p>
<p>Pimpl利用了c++的一个特点，即可以将类的数据成员定义为指向某个已经声明过的类型的指针，这里的类型仅仅作为名字引入，并没有被完整地定义。</p>
<p>该技巧可以避免在头文件中暴露私有细节，因此是促进API接口与实现保持完全分离的重要机制。</p>
<p>此外由于声明了析构函数，导致默认的移动构造/赋值函数不能生成，若默认行为符合自己的需求，则需显式声明 = default（当只在.h里，Impl是个不完整的类型，所以无法在.h类直接 = default，而是在.h声明，在.cpp使= default）</p>
<p>若需要给类提供拷贝性质的函数，需要额外花点心思处理std::unique_ptr(该智能指针不支持拷贝)。</p>
<p><img src="raw.githubusercontent.com/Alphonse-xu/Alphonse-xu.github.io/master/image/pimpl.png" alt="pimpl"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my_class.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_class</span> &#123;</span></span><br><span class="line">    <span class="comment">//  ... 所有的公有/保护接口都可以放在这里 ...</span></span><br><span class="line">    my_class();</span><br><span class="line">    ~my_class();</span><br><span class="line">    my_class(my_class&amp;&amp; v);    <span class="comment">//移动构造</span></span><br><span class="line">    my_class&amp; <span class="keyword">operator</span>=(my_class&amp;&amp; v);    <span class="comment">//移动赋值</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Impl</span>;</span> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Impl&gt; pimpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// my_class.cpp</span></span><br><span class="line"><span class="comment">// ...include其它要依赖的头文件...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"my_class.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_class</span>:</span>:Impl &#123;</span><br><span class="line">  <span class="comment">// 在这里定义所有私有变量和方法(换句话说是my_class类的具体实现细节内容)</span></span><br><span class="line">  <span class="comment">// 现在可以改变实现，而依赖my_class.h的其他类无需重新编译...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">my_class::my_class():pimpl(<span class="built_in">std</span>::make_unique&lt;Impl&gt;())&#123;</span><br><span class="line">    <span class="comment">// ...初始化pimpl... </span></span><br><span class="line">&#125;</span><br><span class="line">my_class::~my_class() = <span class="keyword">default</span>;</span><br><span class="line">my_class::my_class(my_class&amp;&amp; v) = <span class="keyword">default</span>;</span><br><span class="line">my_class::my_class&amp; <span class="keyword">operator</span>=(my_class&amp;&amp; v) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>例如“自动定时器”的API， 它是一个具名对象，当对象被销毁时打印出其生存时间。</p>
<p>AutoTimer.h 如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoTimer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">AutoTimer</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> name)</span></span>;</span><br><span class="line">        ~AutoTimer();</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">getElapsed</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> mName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">        DWORD mStartTime;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">mStartTime</span>;</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上面的h文件可知，该API暴露了定时器在不同平台上存储的底层细节，利用Pimpl特性， 可轻易的隐藏掉这些底层实现的细节， 利用Pimpl特效后新的h文件如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoTimer</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AutoTimer</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name)</span></span>;</span><br><span class="line">    ~AutoTimer();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Impl</span>;</span></span><br><span class="line">    Impl* mImpl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新API更简洁， 没有任何平台相关的预处理指令， 他人也不能通过头文件了解类的任何私有成员。</p>
<p>现在AutoTimer的功能实现都放在内嵌类Impl中了， 具体的AutoTimer的cpp文件如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"AutoTimer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoTimer</span>:</span>:Impl</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getElapsed</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">        <span class="keyword">return</span> (GetTickCount() - mStartTime) / <span class="number">1e3</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">end_time</span>;</span></span><br><span class="line">        gettimeofday(&amp;end_time, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">double</span> t1 = mStartTime.tv_usec / <span class="number">1e6</span> + mStartTime.tv_sec;</span><br><span class="line">        <span class="keyword">double</span> t2 = end_time.tv_usec / <span class="number">1e6</span> + end_time.tv_sec;</span><br><span class="line">        <span class="keyword">return</span> t2 - t1;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> mName;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">    DWORD mStartTime;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">mStartTime</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">AutoTimer::AutoTimer(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">: mImpl(<span class="keyword">new</span> AutoTimer::Impl())</span><br><span class="line">&#123;</span><br><span class="line">    mImpl-&gt;mName = name;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _WIN32</span></span><br><span class="line">    mImpl-&gt;mStartTime = GetTickCount();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    gettimeofday(&amp;mImpl-&gt;mStartTime, <span class="literal">NULL</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AutoTimer::~AutoTimer()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mImpl-&gt;mName &lt;&lt; <span class="string">":took "</span> &lt;&lt; mImpl-&gt;getElapsed() &lt;&lt; <span class="string">" secs"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> mImpl;</span><br><span class="line">    mImpl = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Impl类声明为AutoTimer类的私有内嵌类， 可以避免与该实现相关的符号污染全局命名空间。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="Pimpl的优点"><a href="#Pimpl的优点" class="headerlink" title="Pimpl的优点"></a>Pimpl的优点</h3><ul>
<li><p>接口和实现的分离，私有成员完全可以隐藏在共有接口之外，给用户一个间接明了的使用接口，尤其适合闭源API设计。</p>
</li>
<li><p>降低耦合，对Impl类进行修改，无需重新编译原类</p>
</li>
<li><p>加速编译，减少原类不必要的头文件的依赖</p>
</li>
<li><p>更好的二进制兼容性。二进制兼容性指的是在升级库文件的时候（windows下的dll， uinx下的so），不必重新编译使用这个库的可执行文件或使用这个库的其他库文件，程序的功能不被破坏</p>
</li>
<li><p>可使用惰性分配技术：类的某部分实现可以写成按需分配或者实际使用时再分配，从而节省资源</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>添加了一层封装， 可能进入性能问题</p>
</li>
<li><p>代码可读性降低</p>
</li>
</ul>
<hr>
<h2 id="参考来源"><a href="#参考来源" class="headerlink" title="参考来源"></a>参考来源</h2><p><a href="https://zh.cppreference.com/w/cpp/language/pimpl" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/language/pimpl</a></p>
<p><a href="https://www.jianshu.com/p/b2be3fb1e1d1" target="_blank" rel="noopener">https://www.jianshu.com/p/b2be3fb1e1d1</a> </p>
<p><a href="https://www.cnblogs.com/KillerAery/p/9539705.html" target="_blank" rel="noopener">https://www.cnblogs.com/KillerAery/p/9539705.html</a></p>
<p><a href="https://goodspeedlee.blogspot.com/2016/01/c-pimpl.html" target="_blank" rel="noopener">https://goodspeedlee.blogspot.com/2016/01/c-pimpl.html</a></p>
<p><a href="https://blog.csdn.net/lihao21/article/details/47610309" target="_blank" rel="noopener">https://blog.csdn.net/lihao21/article/details/47610309</a></p>
]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>编程技术</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Bitmap</title>
    <url>/2020/03/09/cppbitmap/</url>
    <content><![CDATA[<h1 id="C-大数据存储-Bitmap"><a href="#C-大数据存储-Bitmap" class="headerlink" title="C++大数据存储  Bitmap"></a>C++大数据存储  Bitmap</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近参与游戏开发遇到了需要保存用户每次的按键。原本打算定义一个结构体，但是了解到有内存占用更少的方法，这就是Bitmap。</p>
]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>编程技术</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>这是另一种GDD的编写模板</title>
    <url>/2020/03/09/myGDD/</url>
    <content><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>Game Title</p>
<p>Game Design Document</p>
<hr>
<p>Changelog</p>
<table>
<thead>
<tr>
<th>Date of change</th>
<th>Change description</th>
<th>Developer Name</th>
</tr>
</thead>
<tbody><tr>
<td>2020</td>
<td>NOTHING</td>
<td>CANAAN</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<p>Table of Contents</p>
<p>Changelog        2</p>
<p>Table of Contents        3</p>
<p>Summary        5</p>
<p>Story        6</p>
<p>Gameplay        7</p>
<p>Levels        8</p>
<p>Art        9</p>
<p>UI, Systems &amp; Options        10</p>
<p>Audio        11</p>
<p>Analysis        12</p>
<p>Target        13</p>
<p>Marketing        14</p>
<p>Development Plan        15</p>
<hr>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Describe the game in 2-5 sentences.</p>
<p>Unique Features</p>
<p>List 2-5 unique selling features of your game.</p>
<p>MVP</p>
<p>Describe the minimal viable product you’ll be delivering.</p>
<hr>
<p>Story Characters</p>
<p>Description</p>
<p>Setting</p>
<p>Description</p>
<p>Narrative</p>
<p>Description</p>
<hr>
<h2 id="Gameplay-Design-Pillars-List-and-explain"><a href="#Gameplay-Design-Pillars-List-and-explain" class="headerlink" title="Gameplay Design Pillars List and explain"></a>Gameplay Design Pillars List and explain</h2><p>Core Loop</p>
<p>Core gameplay loop of the game.</p>
<p>Mechanics</p>
<p>List all relevant mechanics and their use</p>
<p>Dynamics</p>
<p>List and explain how mechanics tie into this</p>
<p>Additional sections (Optional)</p>
<p>List and explain</p>
<hr>
<h2 id="Levels"><a href="#Levels" class="headerlink" title="Levels"></a>Levels</h2><p>Level Progression<br>How the player progresses through the game.</p>
<p>Environments</p>
<p>Description</p>
<p>Link to Level Design Document</p>
<p>Link</p>
<hr>
<h2 id="Art"><a href="#Art" class="headerlink" title="Art"></a>Art</h2><p>Summary<br>Describe and explain</p>
<p>Link to Art Bible</p>
<p>Link</p>
<hr>
<h2 id="UI-Systems-amp-Options"><a href="#UI-Systems-amp-Options" class="headerlink" title="UI, Systems &amp; Options"></a>UI, Systems &amp; Options</h2><p>UI</p>
<p>Description/link to additional documentation</p>
<p>Systems</p>
<p>Description/link to additional documentation</p>
<p>Options &amp; Controls</p>
<p>Description/link to additional documentation</p>
<hr>
<h2 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h2><p>Summary</p>
<p>Describe and explain</p>
<p>Link to Audio Document</p>
<p>Link</p>
<hr>
<h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>Market/Competitor Analysis</p>
<p>Top competitors, market status, conclusions (can link to outside document)</p>
<p>Technical Analysis</p>
<p>Experimental features, used tech (can link to outside document)</p>
<p>Legal Analysis</p>
<p>Trademarked/copyrighted material…</p>
<hr>
<h2 id="Target"><a href="#Target" class="headerlink" title="Target"></a>Target</h2><p>Target Audience</p>
<p>Describe and explain</p>
<p>Target Device</p>
<p>Describe and explain</p>
<p>Target Budget</p>
<p>Describe and explain</p>
<hr>
<h2 id="Marketing"><a href="#Marketing" class="headerlink" title="Marketing"></a>Marketing</h2><p>Promotions</p>
<p>Describe and explain</p>
<p>Community</p>
<p>Describe and explain</p>
<hr>
<h2 id="Development-Plan"><a href="#Development-Plan" class="headerlink" title="Development Plan"></a>Development Plan</h2><p>How will the game be made?</p>
]]></content>
  </entry>
  <entry>
    <title>Leetcode刷题记录：1.两数之和</title>
    <url>/2020/02/21/Leetcode1/</url>
    <content><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><h3 id="1-暴力搜索"><a href="#1-暴力搜索" class="headerlink" title="1. 暴力搜索"></a>1. 暴力搜索</h3><p>遍历每个元素 xxx，并查找是否存在一个值与 target−xtarget - xtarget−x 相等的目标元素。</p>
<p>执行用时：136ms</p>
<p>内存消耗：9.4mb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        for(int i &#x3D; 0;i &lt; nums.size() - 1; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            int side &#x3D; target - nums[i];</span><br><span class="line">            for(int j &#x3D; i + 1; j &lt; nums.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                if(nums[j] &#x3D;&#x3D; side)</span><br><span class="line">                &#123;;</span><br><span class="line">                    return &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时间复杂度：O(n^2)</span><br><span class="line">对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n) 的时间。因此时间复杂度为 O(n^2)</span><br><span class="line"></span><br><span class="line">空间复杂度：O(1)</span><br></pre></td></tr></table></figure>

<h3 id="2-两遍哈希表查找"><a href="#2-两遍哈希表查找" class="headerlink" title="2. 两遍哈希表查找"></a>2. 两遍哈希表查找</h3><p>通过以空间换取速度的方式，我们可以将查找时间从 O(n)O(n)O(n) 降低到 O(1)O(1)O(1)。哈希表正是为此目的而构建的，它支持以 近似 恒定的时间进行快速查找。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)O(n)O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)O(1)O(1)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; numMap;</span><br><span class="line">        for(int i &#x3D; 0;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            numMap[nums[i]] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for(int i &#x3D; 0;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if(numMap.find(target - nums[i]) !&#x3D; numMap.end() &amp;&amp; numMap[target - nums[i]] !&#x3D; i)</span><br><span class="line">            &#123;</span><br><span class="line">                return &#123;i,numMap[target - nums[i]]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>执行用时：136ms</p>
<p>内存消耗：9.4mb</p>
<p>复杂度分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时间复杂度：O(n)，</span><br><span class="line">我们把包含有 n 个元素的列表遍历两次。由于哈希表将查找时间缩短到 O(1)，所以时间复杂度为 O(n)</span><br><span class="line"></span><br><span class="line">空间复杂度：O(n)</span><br><span class="line">所需的额外空间取决于哈希表中存储的元素数量，该表中存储了 n 个元素。</span><br></pre></td></tr></table></figure>

<h3 id="3-一遍哈希表"><a href="#3-一遍哈希表" class="headerlink" title="3. 一遍哈希表"></a>3. 一遍哈希表</h3><p>事实证明，我们可以一次完成。在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
<p>执行用时：136ms</p>
<p>内存消耗：9.4mb</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> side = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(side) != m.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;m[side], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还有一种貌似用时更快的写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; m;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        for(int i &#x3D; 0; i&lt; nums.size(); ++i)&#123;</span><br><span class="line">            if(m.find(target-nums[i])&#x3D;&#x3D;m.end())&#123;</span><br><span class="line">                m[nums[i]]&#x3D;i;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                res.push_back(m[target-nums[i]]);</span><br><span class="line">                res.push_back(i);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>复杂度分析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时间复杂度：O(n)</span><br><span class="line">我们只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 O(1)O(1)O(1) 的时间</span><br><span class="line"></span><br><span class="line">空间复杂度：O(n)</span><br><span class="line">所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n 个元素</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>哈希表在内存消耗有限增大的情况下大大提高了查找速度。大数据快查还是用哈希表较好。</p>
]]></content>
      <categories>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>简单</tag>
      </tags>
  </entry>
  <entry>
    <title>如何编写游戏设计文档</title>
    <url>/2020/02/21/GDDTemp/</url>
    <content><![CDATA[<p>原文章地址：<a href="https://www.gamasutra.com/blogs/LeandroGonzalez/20160726/277928/How_to_Write_a_Game_Design_Document.php" target="_blank" rel="noopener">https://www.gamasutra.com/blogs/LeandroGonzalez/20160726/277928/How_to_Write_a_Game_Design_Document.php</a></p>
<p>原作者：Leandro Gonzalez</p>
<p>翻译：CANAAN</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="开始前的澄清"><a href="#开始前的澄清" class="headerlink" title="开始前的澄清"></a>开始前的澄清</h2><p>当我们初次分享此帖子时（几个月前在Reddit上），出现了一些建设性的、热情的讨论（因为这样我们都成为了更好的游戏设计师）。</p>
<p>我想澄清一些一直被讨论的有争议的事情，您最好在阅读全部内容前知道：</p>
<p><strong>1.使用GDD已成为过去式</strong></p>
<p><strong>2.编写GDD时，您需要直接描述游戏机制</strong></p>
<p>将来我可能会写一篇完整的文章来讨论每个主题，但是现在：</p>
<p>&nbsp;</p>
<p><strong>1.</strong> 与其他行业一样，游戏行业也在不断发展，过去使用的技术已迅速成为历史，特别是仍在上行的年轻行业。<strong>无论您喜欢叫他什么（GDD，Wiki，Board），重要的是在开始工作签要有一些描述您的游戏项目的内容（或与此有关的任何其他项目）。</strong></p>
<p>在Trick，我们将其命名为 GDDs，并且还使用告示板（Trello）来管理任务，并尝试将我们的项目划分成两周一个周期（有点类似于 Scrum）。</p>
<p>我们不选择提前写好GDD然后在开发过程中修改，而是使用团队文档以加快开发速度。然后做一些更正以反映游戏设计阶段团队的反馈或想法。</p>
<p>一旦开始制作游戏，我们就不再更新GDD。所有新想法都直接进入告示板，其中一些被优先考虑（优先级1到3，其中1项是必须要做的事，2项是要做的事，而3项是要做好的事），其中一些放入“想法”列，以便稍后进行评估。</p>
<p>总而言之，无论您使用的是GDD还是其他产品，我们都建议游戏设计师刚开始请考虑将您的想法写成其他人可以阅读和理解的某种类型的文档。</p>
<p>&nbsp;</p>
<p><strong>2.</strong> 我认为对此的答案是“它取决于”，应该在帖子中明确指出。如果您的游戏是《俄罗斯方块》，《太空侵略者》或《小行星》之类的东西……换句话说，故事几乎不存在并且对游戏机制没有任何影响的游戏，那么我同意跳向右是正确的选择进入模板的第4章。</p>
<p>对于像我们在本示例中使用的那样的游戏，描述角色，角色可以做什么以及为什么这样做是很自然的，以便给出一些背景信息。（“地精”可以合并，这转化为某种游戏机制，他们在与“ 德国细菌”战斗，后者解释了游戏的敌人）。</p>
<p>最终，这完全取决于您的游戏和游戏设计风格。只需考虑到一个“简介”部分，您可以在其中简要介绍（在一两个段落中）总体机制，目的是使阅读文档的人可以立即了解您游戏的类型和高级机制，无论您是否直接跳到完整的说明中，或者先绕道介绍一些背景故事。</p>
<p>&nbsp;</p>
<h2 id="那么，我该如何四处记录我想对自己的游戏做些什么？"><a href="#那么，我该如何四处记录我想对自己的游戏做些什么？" class="headerlink" title="那么，我该如何四处记录我想对自己的游戏做些什么？"></a>那么，我该如何四处记录我想对自己的游戏做些什么？</h2><p>首要问题就是当我有一个好主意时，一定是一个使我变得富有的主意（我仍然很穷）。那时，我什至不知道自己想写游戏设计，为此，我需要创建一个游戏设计文档（简称GDD）。</p>
<p>我找了一下GDD的资料，但似乎找不到能帮助我入门的行业标准或模板。</p>
<p>在阅读了几本游戏设计书籍（我强烈推荐杰西·谢尔的《镜头之书》）并阅读了所有的网络资料之后，是时候创建我的第一个GDD了。经过多年的反复发展，它已经演变成以下模板，每次在Trick开始新游戏时都将使用该模板。</p>
<p>这是GDD中每个部分的说明（您可以在此处以下载模板 <a href="http://trickgs.com/blog/wp-content/uploads/2016/01/Tricks-GDD-Template-1.docx" target="_blank" rel="noopener">Trick的GDD模板</a> ）</p>
<p>&nbsp;</p>
<h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>概述这款游戏的内容，不要深入介绍游戏机制或其他任何内容。阅读项目说明后，应该清楚您要制作的游戏难度类型（社交，休闲，硬核等）和游戏玩法类型（益智，RPG，FPS等）。当然，您可以添加更多游戏相关的信息。</p>
<p>理想情况下此部分的长度为一到两个段落。肯定不超过一页。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该游戏设计文档介绍了基于多平台触摸的2D益智游戏的详细信息，该游戏具有新颖的机制以及原创的故事和角色。</span><br><span class="line"></span><br><span class="line">该游戏与其他三消游戏一样玩，但是引入了一些创新。</span><br><span class="line"></span><br><span class="line">名字待定，但备选项是...</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h2 id="1-人物"><a href="#1-人物" class="headerlink" title="1. 人物"></a>1. 人物</h2><p>因为您需要在剧情开始之前介绍角色，所以我们从角色开始。如果您的游戏没有角色或者故事，则可以跳至“游戏性”部分并删除1到3章（或将它们留空）。</p>
<p>字符描述示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">地精是这个游戏的主要角色。这些生物是快乐富有的，但不是贪婪的。他们之所以有钱，是因为他们的祖先与金钱或钱币有关。这也是他们名字的来源。</span><br><span class="line">它们有五颜六色的毛发。</span><br><span class="line"></span><br><span class="line">红色地精是充满激情的地精。黄色比较活跃，可以上下跳跃。绿色地精安静，放松且随和。蓝色地精有点悲伤和脾气暴躁。</span><br><span class="line"></span><br><span class="line">地精也有很多手臂，从1到4不等，它们的手臂有手。它们手臂很强壮能紧紧抓住东西。地精脾气暴躁，喜欢</span><br><span class="line">乱扔东西...</span><br></pre></td></tr></table></figure>

<p>您也可以在此处添加一些角色插图。</p>
<p>&nbsp;</p>
<h2 id="2-故事"><a href="#2-故事" class="headerlink" title="2. 故事"></a>2. 故事</h2><p>“讲故事的艺术中重要一部分是创建读者可以轻松理解的角色，因为读者越理解角色，这些角色的故事就越有趣。” – 杰西·谢尔（Jesse Schell）《透镜之书》</p>
<p>介绍了角色之后，该讨论整个游戏中将会发生的事件。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">地精在城堡内恶作剧，男管家快疯了，但每个人都在快乐。</span><br><span class="line">小丑开玩笑。</span><br><span class="line">德国人在家里看电视。这时他的母亲拜托他。因此他去监视地精。外面正在下雨，德国人全身湿透了，他嫉妒的看向窗内。</span><br><span class="line">一个奇怪的神秘人物（东西）给了他一把钥匙，他可以用它来通过后门进入。他与他的军队，绑架并监禁女地精和宝宝，然后将其他所有人踢出该岛...</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="2-1-主题"><a href="#2-1-主题" class="headerlink" title="2.1. 主题"></a>2.1. 主题</h2><p>“共鸣的主题使您的作品从平凡提升到艺术。艺术家将您带到您永远无法独自去的地方，而主题是到达那里的载具。” - 杰西·谢尔（Jesse Schell）《透镜之书》</p>
<p>能让其他人阅读您的设计很重要。总的来说，主题是关于您想讲的故事类型：是喜剧，是现实生活还是只是幻想… :)</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个关于悲伤和磨难的游戏。有行动和有幸福的时刻，但是在每一章之间，故事必须以一种明确的方式发展————小矮人由于失去家园而感到悲伤。</span><br><span class="line">故事还必须幽默有趣。</span><br></pre></td></tr></table></figure>

<p>如果您认为主题部分与您的游戏无关，则可以跳过此部分。</p>
<p>&nbsp;</p>
<h2 id="3-故事进展"><a href="#3-故事进展" class="headerlink" title="3. 故事进展"></a>3. 故事进展</h2><p>因此，您有一个故事，但是游戏将如何带着玩家体验故事。</p>
<p>“游戏的世界是分割的。您的游戏是通往这个魔幻世界的大门，仅存在在玩家的想象中” – 杰西·谢尔（Jesse Schell）《镜头书》</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">游戏以简短的介绍场景开始。在该场景中，地精被踢出家门，然后他们降落在一个岛上。第一章开始。</span><br><span class="line"></span><br><span class="line">第一章是教程。可以跳过。这时游戏等级很低，管家将会介绍游戏机制。</span><br><span class="line"></span><br><span class="line">一旦玩家完成了教程，他就可以进入第一世界————  森林世界 。</span><br><span class="line"></span><br><span class="line">当玩家完成森林世界时，他会获得“第一把钥匙” ，然后可以选择打开“ 火山世界”或“ 冰山世界”。一旦他击败了这些世界之一...</span><br><span class="line"></span><br><span class="line">构建故事之外的世界也很重要，同时可以发生多个故事。这为续集和商品打开了大门。</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="4-游戏玩法"><a href="#4-游戏玩法" class="headerlink" title="4. 游戏玩法"></a>4. 游戏玩法</h2><p>“ 游戏始于一个想法。” - 杰西·谢尔（Jesse Schell）《透镜之书》</p>
<p>这是GDD中最重要的部分（可能在占游戏的99%）。这里您可以描述游戏玩法（是的，用大写G表示）。</p>
<p>由于本节可能变得很庞大，因此我们继续将其分为对我们有意义的小节。当然，这是一个非常主观的主题，对我们有用的对您可能没用。</p>
<p>&nbsp;</p>
<h2 id="4-1-目标"><a href="#4-1-目标" class="headerlink" title="4.1. 目标"></a>4.1. 目标</h2><p>简而言之，玩家为什么要玩您的游戏？最好将此信息添加到单独的部分，这样您在阅读整个GDD时就不必猜测。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">概述（长期）：帮助地精回到家中</span><br><span class="line"></span><br><span class="line">游戏玩法（短期）：击败敌人，进入下一个级别，等等...</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="4-2-用户技能"><a href="#4-2-用户技能" class="headerlink" title="4.2. 用户技能"></a>4.2. 用户技能</h2><p>这不是最直观的部分，但是如果您考虑玩家玩游戏需要掌握哪些技能，它确实有助于缩小范围。相信我们，编写此列表将帮助您发现游戏设计中的问题。例如，您可能正在尝试为孩子们开发游戏，但意识到您要求他们做一些超过他们这个年龄能做到的事情，或者某些输入内容可能在手机上很容易，但对游戏机却不方便。同样，如果您的游戏将要构建自定义HW，则此列表将使您确定需要哪些组件。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在屏幕上点击</span><br><span class="line">拖放</span><br><span class="line">记忆</span><br><span class="line">解决难题</span><br><span class="line">重新安排作品</span><br><span class="line">管理资源</span><br><span class="line">制定策略</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="4-3-游戏机制"><a href="#4-3-游戏机制" class="headerlink" title="4.3. 游戏机制"></a>4.3. 游戏机制</h2><p>在这里您可以描述游戏机制。当团队开始设计这部分内容时候，对于游戏玩法应该有少许合理的怀疑。这部分可以添加一些图稿或屏幕截图（我们更喜欢做一些原型，并在将资源投入游戏之前弄清楚它们是否有趣）。</p>
<p>这里有完整的书籍和网站包含有关如何描述游戏机制，因此我们在这里不再详细举例说明。底部的链接资源。</p>
<p>&nbsp;</p>
<h2 id="4-4-物品和道具"><a href="#4-4-物品和道具" class="headerlink" title="4.4. 物品和道具"></a>4.4. 物品和道具</h2><p>我们使用本节来详细阐述游戏机制。为了避免将所有内容都包含在一个部分，我们使用上面的部分描述了核心机制，而本部分则讨论了可以添加到游戏中以改善乐趣和赋予玩家力量的东西。</p>
<p>因此，如果您的游戏是三消游戏，那么在上一节中，您将准确描述三消游戏的原理（并将您的改变添加到公式中）。</p>
<p>在本部分中，您将添加玩家可以使用/遇到/购买的所有功能和物品，以及它们如何影响核心游戏玩法。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当完成一个世界时，您可以获得与该世界相关的力量。例如，完成火山世界，您会获得增强地精的物品。可能是围巾，也可能是他们可以穿的东西，这些物品可以稍后在游戏中看到。您可以使用游戏中的货币来升级物品，或使用真钱来获取</span><br><span class="line">游戏中的货币包...</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="4-5-进步与挑战"><a href="#4-5-进步与挑战" class="headerlink" title="4.5. 进步与挑战"></a>4.5. 进步与挑战</h2><p>这也是一个非常主观的部分，可能无法在您的设计中使用。本节的目的是详细说明在整个游戏中难度将如何增加，并确保我们为玩家提供了赶上难度的装备。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">困难会随着敌人更强。为了应对挑战，用户将必须玩得更好，</span><br><span class="line">升级地精并使用物品（同时升级物品）。</span><br></pre></td></tr></table></figure>
<p>此外，在这里我们可以讨论玩家解锁新关卡或任务的方式。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每个BOSS都会掉落一把世界颜色的钥匙。</span><br><span class="line">世界可以以以任何顺序挑战。当用户战胜每个世界并拥有所有钥匙时，他就可以走遍整个世界。</span><br><span class="line">用户挑战每个世界的顺序可以由他选择。</span><br><span class="line">Boss会掉落可以用来打开另一个世界的钥匙。</span><br><span class="line">一旦使用了该物品，它将永远丢失。</span><br><span class="line">用户必须在打开下一个世界之前完成他选择的世界。这时世界的困难度就定下了。</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="4-6-输了"><a href="#4-6-输了" class="headerlink" title="4.6. 输了"></a>4.6. 输了</h2><p>是的，输了！失败条件是什么？时间，血量，所有人？这是描述玩家查看“游戏结束”屏幕的部分。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这些是失败的条件：</span><br><span class="line">时间用尽，行动点数用尽，没有可用伙伴时。</span><br><span class="line"></span><br><span class="line">当玩家失败时，必须有一张显示受伤&#x2F;抓伤的地精的图像。也许他们会掉一些头发，并且您可以看到头发下面的皮肤。</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="5-艺术风格"><a href="#5-艺术风格" class="headerlink" title="5. 艺术风格"></a>5. 艺术风格</h2><p>本节的内容不言自明：在这里您将描述有关游戏外观的想法。一幅图片超过一千个单词，因此这是添加一些概念图的好地方。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这是一个二维等距游戏，具有高质量的2D精灵。</span><br><span class="line">角色设计应类似于吉卜力工作室的设计。</span><br><span class="line"></span><br><span class="line">一切都应该非常生动有趣，并带有播放动画的场景和分层的背景...</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="6-音乐和声音"><a href="#6-音乐和声音" class="headerlink" title="6. 音乐和声音"></a>6. 音乐和声音</h2><p>“音乐是灵魂的语言，因此，它会与演奏者深入交流。” – 杰西·谢尔（Jesse Schell）《透镜之书》</p>
<p>在这里描述您的 Music and Sound FX。根据这在您的游戏中的重要性，您可以将此部分划分为不同的子部分。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">音乐应有复古风格，8位怀旧情调和高品质。</span><br><span class="line"></span><br><span class="line">重要的是，当玩家做得很好时，会有许多声音效果赞美用户。应该有及时的积极反馈。</span><br><span class="line"></span><br><span class="line">当时间用尽时，请添加声音，使用户感到紧张。</span><br><span class="line"></span><br><span class="line">悲伤的场面应该伴有手风琴&#x2F;小提琴音乐，听起来像是悲伤的探戈。</span><br><span class="line"></span><br><span class="line">对于游戏中的音乐，请使用更轻松快乐的乐曲，并随着关卡的前进提高节奏。在山洞中时，音乐听起来应该低沉。</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="7-技术说明"><a href="#7-技术说明" class="headerlink" title="7. 技术说明"></a>7. 技术说明</h2><p>在这里，您将描述将要发行的平台以及将在整个开发过程中使用的工具。这不应该是详细的技术说明，因为您有技术设计文档（TDD）。在这里我们只是讨论浅显的东西。</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最初，该游戏将为移动跨平台游戏：</span><br><span class="line"></span><br><span class="line">• iOS </span><br><span class="line">• Android </span><br><span class="line">• Windows Phone </span><br><span class="line"></span><br><span class="line">还有PC独立版本和Facebook Canvas。</span><br><span class="line">将来可以（通过电子商店）添加Mac或控制台支持。</span><br><span class="line"></span><br><span class="line">考虑以下引擎：Marmalade, Unity 3D, Unreal Engine 4</span><br><span class="line"></span><br><span class="line">对于项目管理，请使用JIRA。使用Perforce来存储代码和资产。</span><br><span class="line"></span><br><span class="line">TBD写在技术设计文档中。</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="8-营销与资金"><a href="#8-营销与资金" class="headerlink" title="8. 营销与资金"></a>8. 营销与资金</h2><p>可选的部分，但现在就写下您的想法，这样您以后就不会忘记它们。重要的是，即使在开始开发之前，也要考虑如何营销。了解制作游戏的钱来自何方也很重要。</p>
<p>“计划是真实的。” – 杰西·谢尔（Jesse Schell）《透镜之书》</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">制作原型是第一件事，然后在Kickstarter众筹，在其中展示。</span><br><span class="line"></span><br><span class="line">尝试达成出版协议。</span><br><span class="line"></span><br><span class="line">我们可以申请政府资助吗？</span><br><span class="line"></span><br><span class="line">创建媒体工具并发到游戏新闻网站。</span><br><span class="line"></span><br><span class="line">创建一个YouTube频道并发布开发日记视频。</span><br><span class="line"></span><br><span class="line">ETC...</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="8-1-人数统计"><a href="#8-1-人数统计" class="headerlink" title="8.1. 人数统计"></a>8.1. 人数统计</h2><p>重要的是要知道您的目标人群，这应该渗入游戏设计中。如果您针对15至25岁的男性，则您的主角可能不应该是粉红色的小马（不是说这有什么问题）。</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">年龄：12至50 </span><br><span class="line"></span><br><span class="line">性别：每个人 大都是休闲玩家</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="8-2-平台与营利"><a href="#8-2-平台与营利" class="headerlink" title="8.2. 平台与营利"></a>8.2. 平台与营利</h2><p>您可以添加更多有关如何在每个平台上进行发行的详细信息。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最初：带游戏内广告的免费android应用，无广告的付费版本。</span><br><span class="line"></span><br><span class="line">免费的带广告的iOS。付费的iOS版本，无广告。</span><br><span class="line"></span><br><span class="line">在游戏购买中。</span><br><span class="line"></span><br><span class="line">考虑：Windows 8，Windows Phone 8，XBOX live 和Nintendo电子商店。</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="8-3-本土化"><a href="#8-3-本土化" class="headerlink" title="8.3. 本土化"></a>8.3. 本土化</h2><p>您支持的语言。只需添加您当前所要考虑的内容，这可能直到以后才会被考虑。</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">最初是英语&#x2F;西班牙语。</span><br><span class="line">以后更新：意大利语，法语，德语等。</span><br><span class="line"></span><br><span class="line">考虑让亚洲出版商将业务扩展到亚洲，这可以为本地化提供帮助。</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<h2 id="9-其他想法"><a href="#9-其他想法" class="headerlink" title="9. 其他想法"></a>9. 其他想法</h2><p>另一个完全可选的部分。如果您不确定自己是否应该添加进游戏，请在此处添加，以免忘记。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">关卡设计师</span><br><span class="line">其他用户创建的排位等级</span><br><span class="line">成就成就</span><br><span class="line">排行榜</span><br><span class="line">游戏应该具有多人游戏模式吗？</span><br></pre></td></tr></table></figure>

<p>“可以肯定的是与类似的单人游戏相比，多人在线游戏的制作工作和花费是其四倍。”</p>
<p>“有一个古老的经验法则，在您拥有完全可用的版本后，需要六个月的时间才能平衡您的游戏” – 《镜头之书》</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>我们希望其他游戏开发人员可以找到有用的模板。期待开始有关如何更改或改进本文档的评论。</p>
<p>请在下面留下您的评论，或通过<a href="mailto:play@trickgs.com">play@trickgs.com</a>与我们联系。如果您想查看我们正在做的工作的最新消息，如果您可以在Twitter或Facebook上关注我们，我们将非常乐意。谢谢！</p>
<p>gnumies_cut以下是一些有趣的资源，以备您继续游戏设计时使用：</p>
<p><a href="http://www.pixelprospector.com/the-big-list-of-game-design/" target="_blank" rel="noopener">http://www.pixelprospector.com/the-big-list-of-game-design/</a></p>
<p><a href="http://gdquest.com/game-design/my-7-most-valuable-game-design-resources/" target="_blank" rel="noopener">http://gdquest.com/game-design/my-7-most-valuable-game-design-resources/</a></p>
]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>游戏文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows安装软件清单</title>
    <url>/2020/01/27/win-software/</url>
    <content><![CDATA[<p>Windows系统缺少一些软件，还不能做到开箱即用。总结一些常用软件，方便重装系统。</p>
<h2 id="影音"><a href="#影音" class="headerlink" title="影音"></a>影音</h2><ol>
<li>网易云音乐</li>
<li>QQ音乐</li>
<li>Potplayer</li>
<li>KODI</li>
<li>OBS</li>
<li>Foobar2000</li>
</ol>
<h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><ol>
<li>扣钉</li>
<li>Visual Studio</li>
<li>Visual Studio Code</li>
<li>Git</li>
<li>Unity3D</li>
<li>Unreal</li>
<li>EgretTools</li>
</ol>
<h2 id="音乐创作"><a href="#音乐创作" class="headerlink" title="音乐创作"></a>音乐创作</h2><ol>
<li>FamiTracker（8Bit音乐创作）</li>
<li>Bfxr（独立游戏最佳伴侣，生成一万种8bit音效不带重样）</li>
</ol>
<h2 id="办公编辑"><a href="#办公编辑" class="headerlink" title="办公编辑"></a>办公编辑</h2><ol>
<li>OFFICE全家桶</li>
<li>Google全家桶</li>
<li>Adobe全家桶</li>
<li>格式工厂</li>
<li>Parsec(远程桌面)</li>
</ol>
<h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>1.有道词典<br>2.欧陆词典</p>
<h2 id="快捷工具"><a href="#快捷工具" class="headerlink" title="快捷工具"></a>快捷工具</h2><ol>
<li>搜索Everything</li>
<li>Ditto</li>
<li>AntRenamer（简易）</li>
<li>BulkRenameUtility（强大）</li>
<li>SpaceSniffer</li>
</ol>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><ol>
<li>Rescue pro</li>
<li>VM Virtualbox</li>
<li>bandi zip</li>
<li>Discord</li>
</ol>
<h2 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h2><ol>
<li>GOG</li>
<li>Steam</li>
<li>UBI</li>
<li>Epic</li>
<li>Battlenet</li>
<li>Origin</li>
</ol>
<h2 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h2><ol>
<li>百度网盘</li>
<li>迅雷极速版</li>
<li>Free download manager</li>
<li>youtube downloader(python)</li>
</ol>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>-其他</tag>
      </tags>
  </entry>
  <entry>
    <title>helloworld</title>
    <url>/2020/01/25/helloworld/</url>
    <content><![CDATA[<p>欢迎来到我的博客！我是迦南君。我将会在这里分享我的一切！</p>
<p>Welcome to my blog,powered by<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is my first post. The theme is Ayer.If you like it,follow it-<a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">Ayer</a>.</p>
<p>Thank my dear girlfriend Rosena,with your company and love.</p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title>about me</title>
    <url>/2020/01/24/about/</url>
    <content><![CDATA[<p>GitHub: alphonse-xu</p>
<p>Email: <a href="mailto:canaan@canaan.website">canaan@canaan.website</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>其他</tag>
      </tags>
  </entry>
</search>
